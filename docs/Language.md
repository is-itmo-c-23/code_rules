### Part III. Тонкости языка

### 1. using namespace

Включать целый namespace опасно, так как из-за этого может возникнуть конфликт имен. Вследствие чего могут возникнуть нетривиальные ошибки компиляции/линковки, а если не повезет, то переменная из namespace может совпасть по названию с какой-то вашей переменной, про которую вы не помните ее область видимости, что приведет к еще более сложнонаходимым багам, хоть все и скомпилируется, но иногда вы будете использовать переменную, думая, что это ваша переменная, и в ней такое-то значение, а значение будет совсем другим. Кроме того, включая namespace, вы нарушаете сам принцип использования namespace'ов.

(c) @radmickey

```C++
// плохо

#include <string>

using namespace std;

int main() {
    string str = "hello world";
}

// хорошо

#include <string>

int main() {
    std::string str = "hello world";
}
```
### 2. Библиотеки языка Си

Не используйте библиотеки языка Си (они заканчиваются на `.h`). Используйте плюсовые аналоги, у них такой же название, только без `.h` в конце и с `c` в начале.

```C++
#include <math.h> // плохо

#include <cmath> // хорошо
```

### 3. const reference

`int`, `char`, `float`, `char*` и т.д. это примитивы. Если вы передаете в функцию/метод не примитивный объект и хотите работать именно с ним (а не с копией), то передавайте его по ссылке (`&`). Если в функции вы его не меняете, то используйте константную ссылке (`const&`).

```C++
void printString(std::string str) { // плохо
    std::cout << str << std::endl;
}

void printString(const std::string& str) { // хорошо
    std::cout << str << std::endl;
}
```

[Тут](https://stackoverflow.com/questions/2627166/what-is-the-difference-between-a-const-reference-and-normal-parameter) можно почитать про const reference.

### 4. Приведение типов

Если вы хотите привести один примитивный тип к другому (т.е. скастить), то используйте C++ cast, а не C-style каст.

```C++
char ch = 'a';
uint64_t ch_uint = ch; // очень плохо

char ch = 'a';
uint64_t ch_uint = (char)ch; // плохо

char ch = 'a';
uint64_t ch_uint = static_cast<uint64_t>(ch); // хорошо
```

### 5. Инвертирование условий

Старайтесь избегать большой вложенности кода, где это возможно. Это позволит писать более чистый и более поддерживаемый код

```C++
std::ifstream file(filename);
if (file.is_open()) { // плохо
     // code
} else {
    return EXIT_FAILURE;
}

if (!ok) { // хорошо
    return EXIT_FAILURE;
}

// code

